<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MonadORE - PoW Mining</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff41;
            overflow-x: hidden;
            position: relative;
        }

        #matrix {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            opacity: 0.15;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            border: 2px solid #00ff41;
            padding: 25px;
            margin-bottom: 30px;
            background: rgba(0, 255, 65, 0.03);
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
            position: relative;
        }

        h1 {
            font-size: 48px;
            text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41;
            letter-spacing: 4px;
            display: inline-block;
        }

        .wallet-btn {
            float: right;
            background: transparent;
            border: 2px solid #00ff41;
            color: #00ff41;
            padding: 12px 25px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }

        .wallet-btn:hover {
            background: #00ff41;
            color: #0a0e27;
            box-shadow: 0 0 20px #00ff41;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-box {
            border: 1px solid #00ff41;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            position: relative;
        }

        .stat-box::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff41, transparent, #00ff41);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .stat-box:hover::before {
            opacity: 1;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff41;
        }

        .mining-zone {
            border: 2px solid #00ff41;
            padding: 40px;
            background: rgba(0, 0, 0, 0.7);
            margin-bottom: 30px;
        }

        .terminal {
            background: #000;
            border: 1px solid #00ff41;
            padding: 20px;
            min-height: 150px;
            margin-bottom: 20px;
            font-size: 14px;
            overflow-y: auto;
            max-height: 300px;
        }

        .terminal-line {
            margin-bottom: 5px;
        }

        .terminal-line::before {
            content: '> ';
            color: #00ff41;
        }

        .terminal-line.success {
            color: #00ff41;
            font-weight: bold;
        }

        .terminal-line.error {
            color: #ff4136;
        }

        .terminal-line.warning {
            color: #ffdc00;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 20px;
            background: transparent;
            border: 2px solid #00ff41;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover:not(:disabled) {
            background: #00ff41;
            color: #0a0e27;
            box-shadow: 0 0 30px #00ff41;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn.mining {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px #00ff41; }
            50% { box-shadow: 0 0 40px #00ff41; }
        }

        .hashrate-display {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 255, 65, 0.05);
            border-left: 3px solid #00ff41;
        }

        .info-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .info-box {
            border: 1px solid #00ff41;
            padding: 25px;
            background: rgba(0, 0, 0, 0.6);
        }

        .info-box h3 {
            margin-bottom: 15px;
            font-size: 20px;
        }

        .info-item {
            margin-bottom: 12px;
            padding-left: 15px;
            border-left: 2px solid #00ff41;
        }

        footer {
            text-align: center;
            padding: 30px;
            border-top: 1px solid #00ff41;
            margin-top: 50px;
            opacity: 0.7;
        }

        footer a {
            color: #00ff41;
            text-decoration: none;
            text-shadow: 0 0 5px #00ff41;
        }

        footer a:hover {
            text-shadow: 0 0 15px #00ff41;
        }

        .glitch {
            position: relative;
        }

        .scan-line {
            position: fixed;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 65, 0.5);
            box-shadow: 0 0 10px #00ff41;
            animation: scan 4s linear infinite;
            z-index: 9999;
            pointer-events: none;
        }

        @keyframes scan {
            from { top: 0; }
            to { top: 100%; }
        }

        @media (max-width: 768px) {
            .info-section {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 32px;
            }
            
            .wallet-btn {
                float: none;
                display: block;
                margin-top: 15px;
            }
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .stop-btn {
            background: rgba(255, 65, 54, 0.1);
            border-color: #ff4136;
            color: #ff4136;
        }

        .stop-btn:hover:not(:disabled) {
            background: #ff4136;
            color: #0a0e27;
            box-shadow: 0 0 30px #ff4136;
        }
    </style>
</head>
<body>
    <div class="scan-line"></div>
    <canvas id="matrix"></canvas>

    <div class="container">
        <header>
            <h1 class="glitch">MONADORE</h1>
            <button class="wallet-btn" onclick="connectWallet()">CONNECT WALLET</button>
            <div style="clear: both; margin-top: 15px;">
                <small>PROOF-OF-WORK MINING PROTOCOL</small>
            </div>
        </header>

        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">YOUR BALANCE</div>
                <div class="stat-value" id="balance">0.0000</div>
                <div class="stat-label">ORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">UNCLAIMED REWARDS</div>
                <div class="stat-value" id="unclaimed">0.0000</div>
                <div class="stat-label">ORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">TOTAL MINED</div>
                <div class="stat-value" id="totalSupply">0.00</div>
                <div class="stat-label">/ 21M ORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">DIFFICULTY</div>
                <div class="stat-value" id="difficulty">0</div>
                <div class="stat-label">LEADING ZEROS</div>
            </div>
        </div>

        <div class="mining-zone">
            <h2 style="margin-bottom: 20px;">&gt;&gt; MINING TERMINAL</h2>
            
            <div class="hashrate-display">
                <div>
                    <strong>HASH RATE:</strong> <span id="hashrate">0</span> H/s
                </div>
                <div>
                    <strong>HASHES TRIED:</strong> <span id="hashcount">0</span>
                </div>
                <div>
                    <strong>COOLDOWN:</strong> <span id="cooldown" class="blink">READY</span>
                </div>
            </div>

            <div class="terminal" id="terminal">
                <div class="terminal-line">System initialized...</div>
                <div class="terminal-line">Awaiting connection...</div>
            </div>

            <div class="controls">
                <button class="btn" id="mineBtn" onclick="startMining()">START MINING</button>
                <button class="btn stop-btn" id="stopBtn" onclick="stopMining()" style="display:none;">STOP MINING</button>
                <button class="btn" id="claimBtn" onclick="claimRewards()">CLAIM REWARDS</button>
            </div>
        </div>

        <div class="info-section">
            <div class="info-box">
                <h3>&gt; PROTOCOL INFO</h3>
                <div class="info-item">
                    <strong>CONTRACT:</strong><br>
                    <small style="word-break: break-all;">0x7Aa87dFeFC4E07EdB718bb0f7e0F18103ab3d415</small>
                </div>
                <div class="info-item">
                    <strong>NETWORK:</strong> Monad Testnet
                </div>
                <div class="info-item">
                    <strong>CHAIN ID:</strong> 10143 (0x279F)
                </div>
                <div class="info-item">
                    <strong>ALGORITHM:</strong> Keccak256 PoW
                </div>
                <div class="info-item">
                    <strong>MIN INTERVAL:</strong> 10 seconds
                </div>
            </div>

            <div class="info-box">
                <h3>&gt; HOW TO MINE</h3>
                <div class="info-item">
                    [1] Connect MetaMask wallet
                </div>
                <div class="info-item">
                    [2] Click START MINING
                </div>
                <div class="info-item">
                    [3] Wait for valid hash discovery
                </div>
                <div class="info-item">
                    [4] Claim accumulated rewards
                </div>
                <div class="info-item" style="margin-top: 15px; color: #ffdc00;">
                    âš  Mining uses local hash validation before submitting to save gas
                </div>
            </div>
        </div>

        <footer>
            <p>CREATED BY <a href="https://x.com/ega_2ez4crypto" target="_blank">@ega_2ez4crypto</a></p>
            <p style="margin-top: 10px; font-size: 12px;">MONADORE v1.1 - DECENTRALIZED MINING</p>
        </footer>
    </div>

    <script>
        const CONTRACT_ADDRESS = '0x7Aa87dFeFC4E07EdB718bb0f7e0F18103ab3d415';
        const RPC_URL = 'https://testnet-rpc.monad.xyz';
        const CHAIN_ID = 10143; // 0x279F
        const ABI = [
            "function mine(uint256 nonce) external",
            "function claimRewards() external",
            "function getMinerInfo(address miner) external view returns (uint256 balance, uint256 unclaimed, uint256 lastMine, uint256 nextMineTime)",
            "function getStats() external view returns (uint256 supply, uint256 diff, uint256 reward, uint256 maxSupply)",
            "function totalSupply() external view returns (uint256)",
            "function difficulty() external view returns (uint256)"
        ];

        let account = null;
        let mining = false;
        let hashCount = 0;
        let startTime = 0;
        let currentDifficulty = 0;

        // Matrix background
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const chars = '01ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        const drops = [];
        for (let i = 0; i < Math.floor(columns); i++) {
            drops[i] = 1;
        }

        function drawMatrix() {
            ctx.fillStyle = 'rgba(10, 14, 39, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff41';
            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < drops.length; i++) {
                const text = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        setInterval(drawMatrix, 33);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        function log(msg, type = 'normal') {
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = 'terminal-line';
            if (type === 'success') line.classList.add('success');
            if (type === 'error') line.classList.add('error');
            if (type === 'warning') line.classList.add('warning');
            line.textContent = msg;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            
            // Keep only last 50 lines
            while (terminal.children.length > 50) {
                terminal.removeChild(terminal.firstChild);
            }
        }

        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    log('ERROR: MetaMask not detected', 'error');
                    alert('Please install MetaMask');
                    return;
                }

                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });

                // Switch to Monad Testnet
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x279F' }]
                    });
                } catch (switchError) {
                    // Chain not added, try to add it
                    if (switchError.code === 4902) {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x279F',
                                    chainName: 'Monad Testnet',
                                    nativeCurrency: { 
                                        name: 'MON', 
                                        symbol: 'MON', 
                                        decimals: 18 
                                    },
                                    rpcUrls: [RPC_URL],
                                    blockExplorerUrls: ['https://explorer.testnet.monad.xyz']
                                }]
                            });
                        } catch (addError) {
                            log('ERROR: Failed to add Monad network', 'error');
                            return;
                        }
                    } else {
                        throw switchError;
                    }
                }

                account = accounts[0];
                document.querySelector('.wallet-btn').textContent = 
                    account.slice(0, 6) + '...' + account.slice(-4);
                log('Wallet connected: ' + account.slice(0, 10) + '...', 'success');
                
                await loadData();
                setInterval(loadData, 5000);
            } catch (error) {
                log('ERROR: ' + error.message, 'error');
            }
        }

        async function loadData() {
            if (!account) return;
            
            try {
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);

                const [minerInfo, stats] = await Promise.all([
                    contract.getMinerInfo(account),
                    contract.getStats()
                ]);

                document.getElementById('balance').textContent = 
                    parseFloat(ethers.utils.formatEther(minerInfo[0])).toFixed(4);
                document.getElementById('unclaimed').textContent = 
                    parseFloat(ethers.utils.formatEther(minerInfo[1])).toFixed(4);
                document.getElementById('totalSupply').textContent = 
                    parseFloat(ethers.utils.formatEther(stats[0])).toFixed(2);
                
                currentDifficulty = stats[1].toNumber();
                document.getElementById('difficulty').textContent = currentDifficulty;

                const now = Math.floor(Date.now() / 1000);
                const cooldown = Math.max(0, minerInfo[3].toNumber() - now);
                
                if (cooldown > 0) {
                    document.getElementById('cooldown').textContent = cooldown + 's';
                    if (!mining) {
                        document.getElementById('mineBtn').disabled = true;
                    }
                } else {
                    document.getElementById('cooldown').textContent = 'READY';
                    if (!mining) {
                        document.getElementById('mineBtn').disabled = false;
                    }
                }

                const unclaimedVal = parseFloat(ethers.utils.formatEther(minerInfo[1]));
                document.getElementById('claimBtn').disabled = unclaimedVal === 0;
            } catch (error) {
                console.error('Load error:', error);
                log('Failed to load data: ' + error.message, 'error');
            }
        }

        function validateHash(miner, nonce, difficulty) {
            // Encode the same way as Solidity: keccak256(abi.encodePacked(miner, nonce))
            const encoded = ethers.utils.solidityPack(
                ['address', 'uint256'],
                [miner, nonce]
            );
            const hash = ethers.utils.keccak256(encoded);
            
            // Count leading zeros in hex (each hex char = 4 bits, so 2 chars = 1 byte = 8 bits)
            const hashStr = hash.slice(2); // Remove '0x'
            let leadingZeros = 0;
            
            for (let i = 0; i < hashStr.length; i++) {
                const hexChar = hashStr[i];
                if (hexChar === '0') {
                    leadingZeros += 4;
                } else {
                    const num = parseInt(hexChar, 16);
                    if (num < 2) leadingZeros += 3;
                    else if (num < 4) leadingZeros += 2;
                    else if (num < 8) leadingZeros += 1;
                    break;
                }
            }
            
            return leadingZeros >= difficulty;
        }

        async function startMining() {
            if (!account) {
                log('ERROR: Connect wallet first', 'error');
                return;
            }

            if (currentDifficulty === 0) {
                log('ERROR: Difficulty not loaded, please wait...', 'error');
                return;
            }

            mining = true;
            hashCount = 0;
            startTime = Date.now();
            
            document.getElementById('mineBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'block';
            document.getElementById('stopBtn').disabled = false;
            
            log('Mining started... Target: ' + currentDifficulty + ' leading zeros', 'warning');
            log('Searching for valid nonce...', 'warning');

            try {
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

                const mineLoop = async () => {
                    while (mining) {
                        const nonce = Math.floor(Math.random() * 1000000000);
                        hashCount++;
                        
                        // Update UI every 100 hashes
                        if (hashCount % 100 === 0) {
                            const elapsed = (Date.now() - startTime) / 1000;
                            const rate = Math.floor(hashCount / elapsed);
                            document.getElementById('hashrate').textContent = rate;
                            document.getElementById('hashcount').textContent = hashCount;
                        }

                        // Validate hash locally first
                        if (validateHash(account, nonce, currentDifficulty)) {
                            log('Valid hash found! Nonce: ' + nonce, 'success');
                            log('Submitting to blockchain...', 'warning');
                            
                            try {
                                const tx = await contract.mine(nonce, { 
                                    gasLimit: 500000 
                                });
                                log('TX sent: ' + tx.hash.slice(0, 16) + '...', 'warning');
                                
                                const receipt = await tx.wait();
                                log('SUCCESS! Block mined. Gas used: ' + receipt.gasUsed.toString(), 'success');
                                
                                mining = false;
                                document.getElementById('mineBtn').style.display = 'block';
                                document.getElementById('stopBtn').style.display = 'none';
                                await loadData();
                                return;
                            } catch (error) {
                                log('TX failed: ' + error.message.substring(0, 80), 'error');
                                if (error.message.includes('user rejected')) {
                                    mining = false;
                                    document.getElementById('mineBtn').style.display = 'block';
                                    document.getElementById('stopBtn').style.display = 'none';
                                    return;
                                }
                                // Continue mining if transaction failed
                            }
                        }

                        // Small delay to prevent browser freeze
                        if (hashCount % 1000 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    }
                };

                await mineLoop();
            } catch (error) {
                log('ERROR: ' + error.message, 'error');
                mining = false;
                document.getElementById('mineBtn').style.display = 'block';
                document.getElementById('stopBtn').style.display = 'none';
            }
        }

        function stopMining() {
            mining = false;
            document.getElementById('mineBtn').style.display = 'block';
            document.getElementById('stopBtn').style.display = 'none';
            log('Mining stopped by user', 'warning');
        }

        async function claimRewards() {
            if (!account) return;
            
            document.getElementById('claimBtn').disabled = true;
            log('Claiming rewards...', 'warning');

            try {
                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);

                const tx = await contract.claimRewards({ gasLimit: 200000 });
                log('TX sent: ' + tx.hash.slice(0, 16) + '...', 'warning');
                
                const receipt = await tx.wait();
                log('Rewards claimed! Gas used: ' + receipt.gasUsed.toString(), 'success');
                await loadData();
            } catch (error) {
                log('ERROR: ' + error.message, 'error');
                document.getElementById('claimBtn').disabled = false;
            }
        }

        // Auto-connect if previously connected
        window.addEventListener('load', () => {
            if (window.ethereum && window.ethereum.selectedAddress) {
                connectWallet();
            }
        });
    </script>
</body>
</html>
