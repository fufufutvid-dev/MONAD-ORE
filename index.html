<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MonadORE - PoW Mining (Fixed)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0e27;
            color: #00ff41;
            overflow-x: hidden;
            position: relative;
        }

        #matrix {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
            opacity: 0.15;
        }

        .container {
            position: relative;
            z-index: 1;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            border: 2px solid #00ff41;
            padding: 25px;
            margin-bottom: 30px;
            background: rgba(0, 255, 65, 0.03);
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
            position: relative;
        }

        h1 {
            font-size: 48px;
            text-shadow: 0 0 10px #00ff41, 0 0 20px #00ff41;
            letter-spacing: 4px;
            display: inline-block;
        }

        .wallet-btn {
            float: right;
            background: transparent;
            border: 2px solid #00ff41;
            color: #00ff41;
            padding: 12px 25px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }

        .wallet-btn:hover {
            background: #00ff41;
            color: #0a0e27;
            box-shadow: 0 0 20px #00ff41;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-box {
            border: 1px solid #00ff41;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            position: relative;
        }

        .stat-box::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff41, transparent, #00ff41);
            z-index: -1;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .stat-box:hover::before {
            opacity: 1;
        }

        .stat-label {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff41;
        }

        .mining-zone {
            border: 2px solid #00ff41;
            padding: 40px;
            background: rgba(0, 0, 0, 0.7);
            margin-bottom: 30px;
        }

        .terminal {
            background: #000;
            border: 1px solid #00ff41;
            padding: 20px;
            min-height: 200px;
            margin-bottom: 20px;
            font-size: 13px;
            overflow-y: auto;
            max-height: 400px;
        }

        .terminal-line {
            margin-bottom: 5px;
            word-break: break-word;
        }

        .terminal-line::before {
            content: '> ';
            color: #00ff41;
        }

        .terminal-line.success {
            color: #00ff41;
            font-weight: bold;
        }

        .terminal-line.error {
            color: #ff4136;
        }

        .terminal-line.warning {
            color: #ffdc00;
        }

        .terminal-line.info {
            color: #7fdbff;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .btn {
            padding: 20px;
            background: transparent;
            border: 2px solid #00ff41;
            color: #00ff41;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn:hover:not(:disabled) {
            background: #00ff41;
            color: #0a0e27;
            box-shadow: 0 0 30px #00ff41;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn.mining {
            animation: pulse 1s infinite;
            background: rgba(0, 255, 65, 0.1);
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px #00ff41; }
            50% { box-shadow: 0 0 40px #00ff41; }
        }

        .hashrate-display {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 255, 65, 0.05);
            border-left: 3px solid #00ff41;
        }

        .info-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .info-box {
            border: 1px solid #00ff41;
            padding: 25px;
            background: rgba(0, 0, 0, 0.6);
        }

        .info-box h3 {
            margin-bottom: 15px;
            font-size: 20px;
        }

        .info-item {
            margin-bottom: 12px;
            padding-left: 15px;
            border-left: 2px solid #00ff41;
        }

        footer {
            text-align: center;
            padding: 30px;
            border-top: 1px solid #00ff41;
            margin-top: 50px;
            opacity: 0.7;
        }

        footer a {
            color: #00ff41;
            text-decoration: none;
            text-shadow: 0 0 5px #00ff41;
        }

        footer a:hover {
            text-shadow: 0 0 15px #00ff41;
        }

        .scan-line {
            position: fixed;
            width: 100%;
            height: 2px;
            background: rgba(0, 255, 65, 0.5);
            box-shadow: 0 0 10px #00ff41;
            animation: scan 4s linear infinite;
            z-index: 9999;
            pointer-events: none;
        }

        @keyframes scan {
            from { top: 0; }
            to { top: 100%; }
        }

        @media (max-width: 768px) {
            .info-section {
                grid-template-columns: 1fr;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 32px;
            }
            
            .wallet-btn {
                float: none;
                display: block;
                margin-top: 15px;
            }
        }

        .blink {
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .stop-btn {
            background: rgba(255, 65, 54, 0.1);
            border-color: #ff4136;
            color: #ff4136;
        }

        .stop-btn:hover:not(:disabled) {
            background: #ff4136;
            color: #0a0e27;
            box-shadow: 0 0 30px #ff4136;
        }
    </style>
</head>
<body>
    <div class="scan-line"></div>
    <canvas id="matrix"></canvas>

    <div class="container">
        <header>
            <h1>MONADORE</h1>
            <button class="wallet-btn" onclick="connectWallet()">CONNECT WALLET</button>
            <div style="clear: both; margin-top: 15px;">
                <small>PROOF-OF-WORK MINING PROTOCOL v2</small>
            </div>
        </header>

        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">YOUR BALANCE</div>
                <div class="stat-value" id="balance">0.0000</div>
                <div class="stat-label">ORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">UNCLAIMED REWARDS</div>
                <div class="stat-value" id="unclaimed">0.0000</div>
                <div class="stat-label">ORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">TOTAL MINED</div>
                <div class="stat-value" id="totalSupply">0.00</div>
                <div class="stat-label">/ 21M ORE</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">DIFFICULTY</div>
                <div class="stat-value" id="difficulty">0</div>
                <div class="stat-label">LEADING ZEROS</div>
            </div>
        </div>

        <div class="mining-zone">
            <h2 style="margin-bottom: 20px;">&gt;&gt; MINING TERMINAL</h2>
            
            <div class="hashrate-display">
                <div>
                    <strong>ATTEMPTS:</strong> <span id="hashcount">0</span>
                </div>
                <div>
                    <strong>VALID HASHES:</strong> <span id="validcount">0</span>
                </div>
                <div>
                    <strong>COOLDOWN:</strong> <span id="cooldown" class="blink">READY</span>
                </div>
            </div>

            <div class="terminal" id="terminal">
                <div class="terminal-line info">MonadORE Mining System v2 - FIXED VERSION</div>
                <div class="terminal-line">System initialized...</div>
                <div class="terminal-line">Awaiting wallet connection...</div>
            </div>

            <div class="controls">
                <button class="btn" id="mineBtn" onclick="startMining()" disabled>START MINING</button>
                <button class="btn stop-btn" id="stopBtn" onclick="stopMining()" style="display:none;">STOP MINING</button>
                <button class="btn" id="claimBtn" onclick="claimRewards()" disabled>CLAIM REWARDS</button>
            </div>
        </div>

        <div class="info-section">
            <div class="info-box">
                <h3>&gt; PROTOCOL INFO</h3>
                <div class="info-item">
                    <strong>CONTRACT:</strong><br>
                    <small style="word-break: break-all;">0xcCd8f63Ca88562399bB423d277B15E5701BD6743</small>
                </div>
                <div class="info-item">
                    <strong>NETWORK:</strong> Monad Testnet
                </div>
                <div class="info-item">
                    <strong>CHAIN ID:</strong> 10143 (0x279F)
                </div>
                <div class="info-item">
                    <strong>RPC:</strong> testnet-rpc.monad.xyz
                </div>
                <div class="info-item">
                    <strong>ALGORITHM:</strong> Keccak256 PoW
                </div>
                <div class="info-item">
                    <strong>MIN INTERVAL:</strong> 10 seconds
                </div>
            </div>

            <div class="info-box">
                <h3>&gt; HOW IT WORKS</h3>
                <div class="info-item">
                    [1] Connect MetaMask to Monad Testnet
                </div>
                <div class="info-item">
                    [2] Click START MINING - system will find valid nonces locally
                </div>
                <div class="info-item">
                    [3] Valid nonces are submitted to contract for verification
                </div>
                <div class="info-item">
                    [4] Wait 10 seconds between successful mines
                </div>
                <div class="info-item">
                    [5] Claim your accumulated rewards anytime
                </div>
                <div class="info-item" style="margin-top: 15px; color: #ffdc00;">
                    âš  Only successful mining submissions cost gas. Failed attempts are free!
                </div>
            </div>
        </div>

        <footer>
            <p>CREATED BY <a href="https://x.com/ega_2ez4crypto" target="_blank">@ega_2ez4crypto</a></p>
            <p style="margin-top: 10px; font-size: 12px;">MONADORE v2.0 - FIXED MINING SYSTEM</p>
        </footer>
    </div>

    <script>
        const CONTRACT_ADDRESS = '0xcCd8f63Ca88562399bB423d277B15E5701BD6743';
        const RPC_URL = 'https://testnet-rpc.monad.xyz';
        const CHAIN_ID = 10143;
        
        const ABI = [
            "function mine(uint256 nonce) external",
            "function claimRewards() external",
            "function getMinerInfo(address miner) external view returns (uint256 balance, uint256 unclaimed, uint256 lastMine, uint256 nextMineTime)",
            "function getStats() external view returns (uint256 supply, uint256 diff, uint256 reward, uint256 maxSupply)",
            "function totalSupply() external view returns (uint256)",
            "function difficulty() external view returns (uint256)",
            "function testNonce(uint256 nonce) external view returns (bool, bytes32)"
        ];

        let account = null;
        let mining = false;
        let attemptCount = 0;
        let validCount = 0;
        let currentDifficulty = 0;
        let provider = null;
        let contract = null;

        // Matrix background animation
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const chars = '01ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        const drops = [];
        for (let i = 0; i < Math.floor(columns); i++) {
            drops[i] = 1;
        }

        function drawMatrix() {
            ctx.fillStyle = 'rgba(10, 14, 39, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff41';
            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < drops.length; i++) {
                const text = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        setInterval(drawMatrix, 33);

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        function log(msg, type = 'normal') {
            const terminal = document.getElementById('terminal');
            const line = document.createElement('div');
            line.className = 'terminal-line';
            if (type === 'success') line.classList.add('success');
            if (type === 'error') line.classList.add('error');
            if (type === 'warning') line.classList.add('warning');
            if (type === 'info') line.classList.add('info');
            
            const timestamp = new Date().toLocaleTimeString();
            line.textContent = `[${timestamp}] ${msg}`;
            terminal.appendChild(line);
            terminal.scrollTop = terminal.scrollHeight;
            
            while (terminal.children.length > 100) {
                terminal.removeChild(terminal.firstChild);
            }
        }

        async function connectWallet() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    log('ERROR: MetaMask not detected!', 'error');
                    alert('Please install MetaMask extension');
                    return;
                }

                log('Requesting wallet connection...', 'info');
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });

                log('Switching to Monad Testnet...', 'info');
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x279F' }]
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        log('Adding Monad Testnet to MetaMask...', 'warning');
                        try {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0x279F',
                                    chainName: 'Monad Testnet',
                                    nativeCurrency: { 
                                        name: 'MON', 
                                        symbol: 'MON', 
                                        decimals: 18 
                                    },
                                    rpcUrls: [RPC_URL],
                                    blockExplorerUrls: ['https://explorer.testnet.monad.xyz']
                                }]
                            });
                            log('Monad Testnet added successfully!', 'success');
                        } catch (addError) {
                            log('ERROR: Failed to add Monad network', 'error');
                            return;
                        }
                    } else {
                        throw switchError;
                    }
                }

                account = accounts[0];
                provider = new ethers.providers.Web3Provider(window.ethereum);
                contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, provider);
                
                document.querySelector('.wallet-btn').textContent = 
                    account.slice(0, 6) + '...' + account.slice(-4);
                log('Wallet connected: ' + account, 'success');
                
                document.getElementById('mineBtn').disabled = false;
                
                await loadData();
                setInterval(loadData, 5000);
                
                log('System ready! You can start mining now.', 'success');
            } catch (error) {
                log('ERROR: ' + error.message, 'error');
                console.error(error);
            }
        }

        async function loadData() {
            if (!account || !contract) return;
            
            try {
                const [minerInfo, stats] = await Promise.all([
                    contract.getMinerInfo(account),
                    contract.getStats()
                ]);

                document.getElementById('balance').textContent = 
                    parseFloat(ethers.utils.formatEther(minerInfo[0])).toFixed(4);
                document.getElementById('unclaimed').textContent = 
                    parseFloat(ethers.utils.formatEther(minerInfo[1])).toFixed(4);
                document.getElementById('totalSupply').textContent = 
                    parseFloat(ethers.utils.formatEther(stats[0])).toFixed(2);
                
                currentDifficulty = stats[1].toNumber();
                document.getElementById('difficulty').textContent = currentDifficulty;

                const now = Math.floor(Date.now() / 1000);
                const nextMineTime = minerInfo[3].toNumber();
                const cooldown = Math.max(0, nextMineTime - now);
                
                if (cooldown > 0) {
                    document.getElementById('cooldown').textContent = cooldown + 's';
                    if (!mining) {
                        document.getElementById('mineBtn').disabled = true;
                    }
                } else {
                    document.getElementById('cooldown').textContent = 'READY';
                    if (!mining) {
                        document.getElementById('mineBtn').disabled = false;
                    }
                }

                const unclaimedVal = parseFloat(ethers.utils.formatEther(minerInfo[1]));
                document.getElementById('claimBtn').disabled = unclaimedVal === 0;
            } catch (error) {
                console.error('Load error:', error);
            }
        }

        // Count leading zero nibbles in a hash
        function countLeadingZeros(hashBytes) {
            let count = 0;
            for (let i = 0; i < hashBytes.length; i++) {
                const byte = hashBytes[i];
                const highNibble = (byte >> 4) & 0x0F;
                const lowNibble = byte & 0x0F;
                
                if (highNibble === 0) {
                    count++;
                    if (lowNibble === 0) {
                        count++;
                    } else {
                        break;
                    }
                } else {
                    break;
                }
            }
            return count;
        }

        // Check if hash is valid locally (matches contract logic)
        function isValidHash(hashString, difficulty) {
            // Remove 0x prefix if present
            const cleanHash = hashString.startsWith('0x') ? hashString.slice(2) : hashString;
            const hashBytes = [];
            
            for (let i = 0; i < cleanHash.length; i += 2) {
                hashBytes.push(parseInt(cleanHash.substr(i, 2), 16));
            }
            
            const leadingZeros = countLeadingZeros(hashBytes);
            return leadingZeros >= difficulty;
        }

        async function startMining() {
            if (!account || !contract) {
                log('ERROR: Please connect wallet first', 'error');
                return;
            }

            if (currentDifficulty === 0) {
                log('ERROR: Difficulty not loaded. Please wait...', 'error');
                return;
            }

            mining = true;
            attemptCount = 0;
            validCount = 0;
            
            document.getElementById('mineBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'block';
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('claimBtn').disabled = true;
            
            log('=== MINING STARTED ===', 'success');
            log('Target difficulty: ' + currentDifficulty + ' leading zero nibbles', 'info');
            log('Searching for valid nonce locally...', 'info');

            try {
                const signer = provider.getSigner();
                const contractWithSigner = contract.connect(signer);

                while (mining) {
                    // Generate random nonce
                    const nonce = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
                    attemptCount++;
                    document.getElementById('hashcount').textContent = attemptCount;
                    
                    // Calculate hash locally (same as contract)
                    const hash = ethers.utils.keccak256(
                        ethers.utils.defaultAbiCoder.encode(
                            ['address', 'uint256'],
                            [account, nonce]
                        )
                    );
                    
                    // Check if valid locally
                    if (isValidHash(hash, currentDifficulty)) {
                        validCount++;
                        document.getElementById('validcount').textContent = validCount;
                        
                        log('VALID HASH FOUND! Nonce: ' + nonce, 'success');
                        log('Hash: ' + hash.slice(0, 20) + '...', 'info');
                        log('Submitting to contract...', 'warning');
                        
                        try {
                            const tx = await contractWithSigner.mine(nonce, { 
                                gasLimit: 500000 
                            });
                            
                            log('TX submitted: ' + tx.hash.slice(0, 20) + '...', 'warning');
                            log('Waiting for confirmation...', 'warning');
                            
                            const receipt = await tx.wait();
                            
                            if (receipt.status === 1) {
                                log('=== MINING SUCCESS! ===', 'success');
                                log('Block mined! Gas used: ' + receipt.gasUsed.toString(), 'success');
                                log('Rewards added to unclaimed balance', 'success');
                                log('Cooldown: 10 seconds before next mine', 'info');
                                
                                mining = false;
                                document.getElementById('mineBtn').style.display = 'block';
                                document.getElementById('stopBtn').style.display = 'none';
                                document.getElementById('claimBtn').disabled = false;
                                
                                await loadData();
                                return;
                            } else {
                                log('TX failed (status 0) - trying again...', 'error');
                            }
                            
                        } catch (error) {
                            if (error.message.includes('user rejected') || error.code === 4001) {
                                log('Transaction rejected by user', 'error');
                                mining = false;
                                document.getElementById('mineBtn').style.display = 'block';
                                document.getElementById('stopBtn').style.display = 'none';
                                return;
                            }
                            
                            if (error.message.includes('Mining too fast')) {
                                log('Cooldown active - waiting...', 'warning');
                                mining = false;
                                document.getElementById('mineBtn').style.display = 'block';
                                document.getElementById('stopBtn').style.display = 'none';
                                await loadData();
                                return;
                            } else if (error.message.includes('Hash already used')) {
                                log('Hash collision detected - finding new nonce...', 'warning');
                            } else if (error.message.includes('Invalid hash')) {
                                log('Contract rejected hash (mismatch?) - retrying...', 'error');
                            } else {
                                const shortMsg = error.message.substring(0, 150);
                                log('Error: ' + shortMsg, 'error');
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                    }
                    
                    // Progress update every 1000 attempts
                    if (attemptCount % 1000 === 0) {
                        log('Checked ' + attemptCount + ' nonces... (Success rate: ' + 
                            ((validCount / attemptCount) * 100).toFixed(3) + '%)', 'info');
                    }
                    
                    // Small delay to prevent browser freeze
                    if (attemptCount % 100 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }
            } catch (error) {
                log('CRITICAL ERROR: ' + error.message, 'error');
                console.error(error);
                mining = false;
                document.getElementById('mineBtn').style.display = 'block';
                document.getElementById('stopBtn').style.display = 'none';
            }
        }

        function stopMining() {
            mining = false;
            document.getElementById('mineBtn').style.display = 'block';
            document.getElementById('stopBtn').style.display = 'none';
            log('=== MINING STOPPED BY USER ===', 'warning');
            log('Total attempts: ' + attemptCount, 'info');
            log('Valid hashes found: ' + validCount, 'info');
        }

        async function claimRewards() {
            if (!account || !contract) return;
            
            document.getElementById('claimBtn').disabled = true;
            log('Claiming rewards...', 'warning');

            try {
                const signer = provider.getSigner();
                const contractWithSigner = contract.connect(signer);

                const tx = await contractWithSigner.claimRewards({ gasLimit: 200000 });
                log('TX sent: ' + tx.hash.slice(0, 20) + '...', 'warning');
                
                const receipt = await tx.wait();
                log('=== REWARDS CLAIMED! ===', 'success');
                log('Gas used: ' + receipt.gasUsed.toString(), 'info');
                
                await loadData();
            } catch (error) {
                log('ERROR: ' + error.message, 'error');
                document.getElementById('claimBtn').disabled = false;
            }
        }

        // Auto-connect if wallet is already connected
        window.addEventListener('load', () => {
            if (window.ethereum && window.ethereum.selectedAddress) {
                connectWallet();
            }
        });

        // Handle account changes
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', (accounts) => {
                if (accounts.length === 0) {
                    log('Wallet disconnected', 'warning');
                    location.reload();
                } else {
                    log('Account changed, reloading...', 'info');
                    location.reload();
                }
            });

            window.ethereum.on('chainChanged', () => {
                log('Network changed, reloading...', 'info');
                location.reload();
            });
        }
    </script>
</body>
</html>
